from qgis.core import (
    QgsPointXY,
    QgsGeometry,
    QgsProject,
    QgsVectorLayer,
    QgsFeature,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsLineString,
    QgsSpatialIndex
)
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
import math

try:
    # Coordenadas fornecidas
    x = 510807
    y = 8649627
    zone = 24

    # Nome da camada de buffer e CRS dependendo da zona
    if zone == 24:
        buffer_layer_name = "FXD24"
        municipios_layer_name = "municipios24"
        shape_layer_name = "shape24"
        crs_utm = QgsCoordinateReferenceSystem("EPSG:31984")  # SIRGAS 2000 / UTM zone 24S
    elif zone == 23:
        buffer_layer_name = "FXD23"
        municipios_layer_name = "municipios23"
        shape_layer_name = "shape23"
        crs_utm = QgsCoordinateReferenceSystem("EPSG:31983")  # SIRGAS 2000 / UTM zone 23S
    else:
        raise ValueError("Zona inválida. Use 23 ou 24.")

    # Alterar o SRC do projeto de acordo com a zona
    QgsProject.instance().setCrs(crs_utm)

    # Obter a camada de buffer pelo nome
    buffer_layers = QgsProject.instance().mapLayersByName(buffer_layer_name)
    if not buffer_layers:
        print(f"Camada {buffer_layer_name} não encontrada")
    else:
        buffer_layer = buffer_layers[0]  # Pega a primeira camada encontrada com o nome

        municipios_layers = QgsProject.instance().mapLayersByName(municipios_layer_name)
        if not municipios_layers:
            print(f"Camada {municipios_layer_name} não encontrada")
        else:
            municipios_layer = municipios_layers[0]

            # Obter a camada de shape pelo nome
            shape_layers = QgsProject.instance().mapLayersByName(shape_layer_name)
            if not shape_layers:
                print(f"Camada {shape_layer_name} não encontrada")
            else:
                shape_layer = shape_layers[0]

                # Definir CRS do projeto atual
                crs_project = QgsProject.instance().crs()

                # Criar um transformador de coordenadas
                transform = QgsCoordinateTransform(crs_utm, crs_project, QgsProject.instance())

                # Criar um ponto a partir das coordenadas fornecidas e transformá-lo
                point = QgsPointXY(x, y)
                point_geometry = QgsGeometry.fromPointXY(point)
                point_geometry.transform(transform)

                # Verificar se o ponto intersecta com algum polígono da camada de buffer
                is_within_buffer = False
                buffer_info = {}

                for feature in buffer_layer.getFeatures():
                    if feature.geometry().intersects(point_geometry):
                        is_within_buffer = True
                        # Obter os atributos do ponto
                        buffer_info = {
                            "RODOVIA": feature["RODOVIA"],
                            "LOCAL_IN_": feature["LOCAL_IN_"],
                            "LOCAL_FIM": feature["LOCAL_FIM"],
                            "JURISDI_C": feature["JURISDI_C"],
                            "TOTAL FXD": feature["TOTAL FXD"],
                            "AMPARO LEG": feature["AMPARO LEG"],
                            "TRECHO": f"{feature['LOCAL_IN_']} - {feature['LOCAL_FIM']}"
                        }
                        break

                # Verificar em qual município o ponto está localizado
                municipio_nome = "N/A"
                for municipio in municipios_layer.getFeatures():
                    if municipio.geometry().contains(point_geometry):
                        municipio_nome = municipio["NM_MUN"]
                        break

                # Criar uma linha central a partir dos polígonos da camada de buffer
                central_line = []
                for feature in buffer_layer.getFeatures():
                    geom = feature.geometry()
                    if geom.isMultipart():
                        for part in geom.asMultiPolygon():
                            for ring in part:
                                central_line.extend(ring)
                    else:
                        for ring in geom.asPolygon():
                            central_line.extend(ring)
                central_line = QgsGeometry.fromPolylineXY([QgsPointXY(pt) for pt in central_line])

                # Encontrar a feição mais próxima da linha central
                spatial_index = QgsSpatialIndex(shape_layer.getFeatures())
                nearest_ids = spatial_index.nearestNeighbor(point, 1)
                closest_feature = None
                if nearest_ids:
                    closest_feature = shape_layer.getFeature(nearest_ids[0])

                # Calcular o km baseado nas regras fornecidas
                km_medido = None
                if closest_feature:
                    km_inicial = closest_feature["KM_INICIAL"]
                    km_final = closest_feature["KM_FINAL"]

                    if km_inicial == 0:
                        # Medir a distância até a feição posterior
                        min_distance_posterior = None
                        for feature in shape_layer.getFeatures():
                            if feature["KM_INICIAL"] > closest_feature["KM_INICIAL"]:
                                shape_geometry = feature.geometry()
                                distance = point_geometry.distance(shape_geometry)
                                if min_distance_posterior is None or distance < min_distance_posterior:
                                    min_distance_posterior = distance
                        if min_distance_posterior is not None:
                            km_medido = min_distance_posterior - km_final
                    else:
                        # Medir a distância até a feição anterior
                        min_distance_anterior = None
                        for feature in shape_layer.getFeatures():
                            if feature["KM_FINAL"] < closest_feature["KM_INICIAL"]:
                                shape_geometry = feature.geometry()
                                distance = point_geometry.distance(shape_geometry)
                                if min_distance_anterior is None or distance < min_distance_anterior:
                                    min_distance_anterior = distance
                        if min_distance_anterior is not None:
                            km_medido = min_distance_anterior + km_inicial

                # Criar uma nova camada de vetor de pontos (permanente)
                point_layer = QgsVectorLayer(
                    f"Point?crs={crs_project.authid()}&field=id:integer&field=in_buffer:string(3)",
                    "Marcação",
                    "memory"
                )
                pr = point_layer.dataProvider()

                # Adicionar o ponto à camada com um atributo indicando se está no buffer
                feature = QgsFeature()
                feature.setGeometry(point_geometry)
                feature.setAttributes([1, "Sim" if is_within_buffer else "Não"])
                pr.addFeature(feature)
                point_layer.updateFields()
                QgsProject.instance().addMapLayer(point_layer)

                # Centralizar o mapa no ponto adicionado e garantir que o ponto seja visível
                iface.mapCanvas().setExtent(point_layer.extent())
                iface.mapCanvas().refresh()

                # Printar o resultado no console
                if is_within_buffer:
                    print("Dentro da FXD")
                    print(f"RODOVIA: {buffer_info.get('RODOVIA', 'N/A')}")
                    print(f"TRECHO: {buffer_info.get('TRECHO', 'N/A')}")
                    print(f"JURISDIÇÃO: {buffer_info.get('JURISDI_C', 'N/A')}")
                    print(f"LARGURA FXD: {buffer_info.get('TOTAL FXD', 'N/A')}")
                    print(f"AMPARO LEGAL: {buffer_info.get('AMPARO LEG', 'N/A')}")
                    print(f"MUNICÍPIO: {municipio_nome}")
                    if min_distance is not None:
                        print(f"Coordenada distando aproximadamente: {min_distance:.2f} m do eixo da BA.")
                    if km_medido is not None:
                        print(f"Distância calculada (km): {km_medido:.2f}")
                else:
                    print(f"Coordenada encontra-se cerca de: {min_distance:.2f} m do eixo da BA.")
                    print(f"MUNICÍPIO: {municipio_nome}")

except Exception as e:
    print(f"Ocorreu um erro: {e}")
